{
  "item": [
    {
      "id": "c530bae2-25a2-40e5-ab47-6131fc1ded57",
      "name": "iam/v2/api-keys",
      "item": [
        null,
        {
          "id": "164d5eee-e3a2-46f8-bcfc-d00268eda1c9",
          "name": "Create an API Key",
          "request": {
            "name": "Create an API Key",
            "description": {
              "content": "[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)\n\nMake a request to create an API key.",
              "type": "text/plain"
            },
            "url": {
              "path": [
                "iam",
                "v2",
                "api-keys"
              ],
              "host": [
                "{{baseUrl}}"
              ],
              "query": [],
              "variable": []
            },
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Accept",
                "value": "application/json"
              }
            ],
            "method": "POST",
            "auth": {
              "type": "basic",
              "basic": [
                {
                  "key": "username",
                  "value": "{{basicAuthUsername}}"
                },
                {
                  "key": "password",
                  "value": "{{basicAuthPassword}}"
                }
              ]
            },
            "body": {
              "mode": "raw",
              "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "response": [
            {
              "id": "37fb5f9d-fef4-4938-b3ab-250d487769a1",
              "name": "An API Key is being created.",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Accepted",
              "code": 202,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "disabled": false,
                  "description": "The maximum number of requests you're permitted to make per time period.",
                  "key": "X-RateLimit-Limit",
                  "value": "{{X-RateLimit-Limit}}"
                },
                {
                  "disabled": false,
                  "description": "The number of requests remaining in the current rate limit window.",
                  "key": "X-RateLimit-Remaining",
                  "value": "{{X-RateLimit-Remaining}}"
                },
                {
                  "disabled": false,
                  "description": "The relative time in seconds until the current rate-limit window resets.  \n  \n**Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues.",
                  "key": "X-RateLimit-Reset",
                  "value": "{{X-RateLimit-Reset}}"
                },
                {
                  "disabled": false,
                  "description": "ApiKey resource uri",
                  "key": "Location",
                  "value": "{{Location}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"spec\": {\n    \"owner\": {},\n    \"secret\": \"R15hoiDIq8Nxu/lY4mPO3DwAVIfU5W7OI+efsB607mLgHTnVW5XJGVqX2ysDx987\",\n    \"display_name\": \"CI kafka access key\",\n    \"description\": \"This API key provides kafka access to cluster x\",\n    \"resource\": {}\n  },\n  \"api_version\": \"iam/v2\",\n  \"kind\": \"ApiKey\",\n  \"id\": \"dlz-f3a90de\",\n  \"metadata\": {\n    \"self\": {},\n    \"resource_name\": {},\n    \"created_at\": {\n      \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n    },\n    \"updated_at\": {\n      \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n    },\n    \"deleted_at\": {\n      \"value\": \"<Error: Too many levels of nesting to fake this schema>\"\n    }\n  }\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "290cbd7c-ca0a-4824-ba8f-171721c57d02",
              "name": "Bad Request",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Bad Request",
              "code": 400,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"status\": \"400\",\n      \"code\": \"invalid_filter\",\n      \"title\": \"Invalid Filter\",\n      \"detail\": \"The 'delorean' resource can't be filtered by 'num_doors'\",\n      \"source\": {\n        \"parameter\": \"num_doors\"\n      }\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "0de4a8d8-70ca-4779-b028-90a28ca2a0a7",
              "name": "The request lacks valid authentication credentials for this resource.",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Unauthorized",
              "code": 401,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "WWW-Authenticate",
                  "value": "{{WWW-Authenticate}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"status\": \"401\",\n      \"code\": \"user_unauthenticated\",\n      \"title\": \"Authentication Required\",\n      \"detail\": \"Valid authentication credentials must be provided\"\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "800e477a-9bd2-420f-96e1-023f0ef88be5",
              "name": "The request would exceed one or more quotas.",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Payment Required",
              "code": 402,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"status\": \"402\",\n      \"code\": \"quota_exceeded\",\n      \"title\": \"Kafka Clusters Per Org Quota Exceeded\",\n      \"detail\": \"The request would exceed the quota: kafka_clusters_per_environment\"\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "3f1a8574-ee45-433e-9f90-f077ee8aef48",
              "name": "The access credentials were considered insufficient to grant access",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Forbidden",
              "code": 403,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"status\": \"403\",\n      \"code\": \"user_unauthorized\",\n      \"title\": \"User Access Unauthorized\",\n      \"detail\": \"The user 'mcfly' is not allowed to access the 'delorean' resource without the 'plutonium' role.\"\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "6316e083-359c-4518-ab63-88cdd984cd15",
              "name": "The request is in conflict with the current server state",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Conflict",
              "code": 409,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "disabled": false,
                  "description": "Resource URI of conflicting resource",
                  "key": "Location",
                  "value": "{{Location}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"status\": \"409\",\n      \"code\": \"resource_already_exists\",\n      \"title\": \"Resource Already exists\",\n      \"detail\": \"The entitlement '91e3e86f-fca6-4f14-98f5-a48e64113ce2' already exists.\"\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "1b11ab56-9aaf-44dc-bc5c-f955725b42ea",
              "name": "Validation Failed",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Unprocessable Entity (WebDAV) (RFC 4918)",
              "code": 422,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    },\n    {\n      \"status\": \"422\",\n      \"code\": \"invalid_configuration\",\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"title\": \"Validation Failed\",\n      \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n      \"source\": {\n        \"pointer\": \"/cluster/storage_size\"\n      }\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            },
            {
              "id": "a13881d3-ba97-44e2-a367-d59a999ab767",
              "name": "Rate Limit Exceeded",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Too Many Requests",
              "code": 429,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "disabled": false,
                  "description": "The maximum number of requests you're permitted to make per time period.",
                  "key": "X-RateLimit-Limit",
                  "value": "{{X-RateLimit-Limit}}"
                },
                {
                  "disabled": false,
                  "description": "The number of requests remaining in the current rate limit window.",
                  "key": "X-RateLimit-Remaining",
                  "value": "{{X-RateLimit-Remaining}}"
                },
                {
                  "disabled": false,
                  "description": "The relative time in seconds until the current rate-limit window resets.  \n  \n**Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues.",
                  "key": "X-RateLimit-Reset",
                  "value": "{{X-RateLimit-Reset}}"
                },
                {
                  "disabled": false,
                  "description": "The number of seconds to wait until the rate limit window resets. Only sent when the rate limit is reached.",
                  "key": "Retry-After",
                  "value": "{{Retry-After}}"
                },
                {
                  "key": "Content-Type",
                  "value": "text/plain"
                }
              ],
              "body": "",
              "cookie": [],
              "_postman_previewlanguage": "text"
            },
            {
              "id": "8575bdb9-4a52-4f35-9384-73a08468fe34",
              "name": "Oops, something went wrong!",
              "originalRequest": {
                "url": {
                  "path": [
                    "iam",
                    "v2",
                    "api-keys"
                  ],
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "query": [],
                  "variable": []
                },
                "header": [
                  {
                    "description": {
                      "content": "Added as a part of security scheme: basic",
                      "type": "text/plain"
                    },
                    "key": "Authorization",
                    "value": "{{Authorization}}"
                  },
                  {
                    "key": "Accept",
                    "value": "application/json"
                  }
                ],
                "method": "POST",
                "body": {
                  "mode": "raw",
                  "raw": "{\n    \"spec\": \"{{spec}}\",\n    \"metadata\": {\n        \"self\": {},\n        \"resource_name\": {}\n    }\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                }
              },
              "status": "Internal Server Error",
              "code": 500,
              "header": [
                {
                  "disabled": false,
                  "description": "The unique identifier for the API request.",
                  "key": "X-Request-Id",
                  "value": "{{X-Request-Id}}"
                },
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": "{\n  \"errors\": [\n    {\n      \"id\": \"ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d\",\n      \"status\": \"500\",\n      \"code\": \"out_of_gas\",\n      \"title\": \"DeLorean Out Of Gas\",\n      \"detail\": \"The DeLorean has run out of gas, but Doc Brown will fill 'er up for you asap\"\n    }\n  ]\n}",
              "cookie": [],
              "_postman_previewlanguage": "json"
            }
          ],
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  " \n// ********RoostGPT********\n/*\nTest generated by RoostGPT for test post-man using AI Type Open AI and AI Model gpt-4\n\n\nTest generated for /iam/v2/api-keys for http method type post in postman framework\n\n*/\n\n// ********RoostGPT********\n\n\nconst ld = require('lodash');\nlet responseData;\nconst contentType = pm.response.headers.get('Content-Type');\nif(contentType === \"application/xml\"){\n    var parseString = require('xml2js').parseString;\n    parseString(pm.response.body, function (err,result) {\n      if (err) {\n        console.error('Error parsing XML:', err);\n      } else {\n        responseData = result;  \n      }\n    });\n} else{\n    responseData = pm.response.json();\n}\nif (pm.variables.get(\"statusCode\")) {\n  // Compare the statusCode variable with the response code for assertion\n    pm.expect(parseInt(pm.variables.get(\"statusCode\"))).to.be.equal(pm.response.code);\n}\n\n// let responseTime = 800\n// pm.expect(pm.response.responseTime).to.be.below(responseTime);\n\nif (pm.response.code == 202){\n    pm.test(\"An API Key is being created.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Accepted\");\n        pm.test('Response has the `api_version` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`api_version`)){\n                if(pm.expect(ld.get(pm.response.json(), `api_version`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `api_version`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n \n        pm.test('api_version to be one of enum', function(){ \n            pm.expect(ld.get(responseData, \"api_version\", \"\")).to.include.oneOf([\"iam/v2\"]);\n        })\n\n        pm.test('Response has the `kind` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`kind`)){\n                if(pm.expect(ld.get(pm.response.json(), `kind`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `kind`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n \n        pm.test('kind to be one of enum', function(){ \n            pm.expect(ld.get(responseData, \"kind\", \"\")).to.include.oneOf([\"ApiKey\"]);\n        })\n\n        pm.test('Response has the `id` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`id`)){\n                if(pm.expect(ld.get(pm.response.json(), `id`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `id`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n  \n        pm.test('id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test('Response has the `spec` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`spec`)){\n                if(pm.expect(ld.get(pm.response.json(), `spec`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `spec`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `spec.secret` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`spec.secret`)){\n                if(pm.expect(ld.get(pm.response.json(), `spec.secret`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `spec.secret`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `spec.display_name` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`spec.display_name`)){\n                if(pm.expect(ld.get(pm.response.json(), `spec.display_name`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `spec.display_name`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `spec.description` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`spec.description`)){\n                if(pm.expect(ld.get(pm.response.json(), `spec.description`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `spec.description`, null)).to.equal(\"string\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `spec` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`spec`)){\n                if(pm.expect(ld.get(pm.response.json(), `spec`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `spec`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n        pm.test('Response has the `spec` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`spec`)){\n                if(pm.expect(ld.get(pm.response.json(), `spec`, null)).to.exist){\n                  pm.expect(typeof ld.get(pm.response.json(), `spec`, null)).to.equal(\"object\");\n                }\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 400){\n    pm.test(\"Bad Request\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Bad Request\");\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n \n        pm.test('errors has unique values',function(){\n          pm.expect(ld.uniq(ld.get(responseData, \"errors\", [])).length).to.be.eql(_.get(responseData, \"errors\", []).length);\n        })\n\n        pm.test(`Each object in the errors field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`errors`);\n            let errorsArray = ld.get(pm.response.json(), `errors`, \"\");\n            for (let errors_it = 0; errors_it < errorsArray.length; errors_it++) {\n                let iterator = errors_it;\n                \t\n        pm.test(`${iterator} element of array 'errors[${errors_it}].id' has 'id' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].id`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test('errors[${errors_it}].id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"errors[${errors_it}].id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].status' has 'status' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].status`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].status`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].code' has 'code' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].code`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].code`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].title' has 'title' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].title`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].title`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].detail' has 'detail' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].detail`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].detail`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source' has 'source' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.pointer' has 'pointer' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.pointer`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.pointer`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.parameter' has 'parameter' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.parameter`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.parameter`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errorsArray'has 'error_code' as number`,function(){ \n            if(pm.expect(ld.get(responseData, `errors[${errors_it}].error_code`, 200)).to.exist){\n              pm.expect(typeof ld.get(responseData,`errors[${errors_it}].error_code`, 200)).to.equal(\"number\");\n            }\n      \n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].message' has 'message' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].message`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].message`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 401){\n    pm.test(\"The request lacks valid authentication credentials for this resource.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unauthorized\");\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n \n        pm.test('errors has unique values',function(){\n          pm.expect(ld.uniq(ld.get(responseData, \"errors\", [])).length).to.be.eql(_.get(responseData, \"errors\", []).length);\n        })\n\n        pm.test(`Each object in the errors field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`errors`);\n            let errorsArray = ld.get(pm.response.json(), `errors`, \"\");\n            for (let errors_it = 0; errors_it < errorsArray.length; errors_it++) {\n                let iterator = errors_it;\n                \t\n        pm.test(`${iterator} element of array 'errors[${errors_it}].id' has 'id' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].id`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test('errors[${errors_it}].id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"errors[${errors_it}].id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].status' has 'status' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].status`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].status`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].code' has 'code' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].code`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].code`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].title' has 'title' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].title`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].title`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].detail' has 'detail' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].detail`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].detail`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source' has 'source' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.pointer' has 'pointer' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.pointer`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.pointer`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.parameter' has 'parameter' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.parameter`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.parameter`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errorsArray'has 'error_code' as number`,function(){ \n            if(pm.expect(ld.get(responseData, `errors[${errors_it}].error_code`, 200)).to.exist){\n              pm.expect(typeof ld.get(responseData,`errors[${errors_it}].error_code`, 200)).to.equal(\"number\");\n            }\n      \n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].message' has 'message' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].message`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].message`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 402){\n    pm.test(\"The request would exceed one or more quotas.\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Payment Required\");\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n \n        pm.test('errors has unique values',function(){\n          pm.expect(ld.uniq(ld.get(responseData, \"errors\", [])).length).to.be.eql(_.get(responseData, \"errors\", []).length);\n        })\n\n        pm.test(`Each object in the errors field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`errors`);\n            let errorsArray = ld.get(pm.response.json(), `errors`, \"\");\n            for (let errors_it = 0; errors_it < errorsArray.length; errors_it++) {\n                let iterator = errors_it;\n                \t\n        pm.test(`${iterator} element of array 'errors[${errors_it}].id' has 'id' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].id`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test('errors[${errors_it}].id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"errors[${errors_it}].id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].status' has 'status' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].status`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].status`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].code' has 'code' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].code`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].code`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].title' has 'title' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].title`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].title`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].detail' has 'detail' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].detail`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].detail`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source' has 'source' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.pointer' has 'pointer' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.pointer`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.pointer`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.parameter' has 'parameter' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.parameter`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.parameter`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errorsArray'has 'error_code' as number`,function(){ \n            if(pm.expect(ld.get(responseData, `errors[${errors_it}].error_code`, 200)).to.exist){\n              pm.expect(typeof ld.get(responseData,`errors[${errors_it}].error_code`, 200)).to.equal(\"number\");\n            }\n      \n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].message' has 'message' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].message`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].message`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 403){\n    pm.test(\"The access credentials were considered insufficient to grant access\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Forbidden\");\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n \n        pm.test('errors has unique values',function(){\n          pm.expect(ld.uniq(ld.get(responseData, \"errors\", [])).length).to.be.eql(_.get(responseData, \"errors\", []).length);\n        })\n\n        pm.test(`Each object in the errors field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`errors`);\n            let errorsArray = ld.get(pm.response.json(), `errors`, \"\");\n            for (let errors_it = 0; errors_it < errorsArray.length; errors_it++) {\n                let iterator = errors_it;\n                \t\n        pm.test(`${iterator} element of array 'errors[${errors_it}].id' has 'id' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].id`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test('errors[${errors_it}].id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"errors[${errors_it}].id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].status' has 'status' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].status`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].status`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].code' has 'code' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].code`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].code`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].title' has 'title' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].title`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].title`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].detail' has 'detail' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].detail`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].detail`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source' has 'source' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.pointer' has 'pointer' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.pointer`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.pointer`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.parameter' has 'parameter' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.parameter`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.parameter`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errorsArray'has 'error_code' as number`,function(){ \n            if(pm.expect(ld.get(responseData, `errors[${errors_it}].error_code`, 200)).to.exist){\n              pm.expect(typeof ld.get(responseData,`errors[${errors_it}].error_code`, 200)).to.equal(\"number\");\n            }\n      \n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].message' has 'message' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].message`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].message`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 409){\n    pm.test(\"The request is in conflict with the current server state\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Conflict\");\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n \n        pm.test('errors has unique values',function(){\n          pm.expect(ld.uniq(ld.get(responseData, \"errors\", [])).length).to.be.eql(_.get(responseData, \"errors\", []).length);\n        })\n\n        pm.test(`Each object in the errors field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`errors`);\n            let errorsArray = ld.get(pm.response.json(), `errors`, \"\");\n            for (let errors_it = 0; errors_it < errorsArray.length; errors_it++) {\n                let iterator = errors_it;\n                \t\n        pm.test(`${iterator} element of array 'errors[${errors_it}].id' has 'id' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].id`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test('errors[${errors_it}].id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"errors[${errors_it}].id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].status' has 'status' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].status`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].status`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].code' has 'code' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].code`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].code`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].title' has 'title' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].title`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].title`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].detail' has 'detail' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].detail`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].detail`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source' has 'source' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.pointer' has 'pointer' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.pointer`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.pointer`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.parameter' has 'parameter' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.parameter`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.parameter`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errorsArray'has 'error_code' as number`,function(){ \n            if(pm.expect(ld.get(responseData, `errors[${errors_it}].error_code`, 200)).to.exist){\n              pm.expect(typeof ld.get(responseData,`errors[${errors_it}].error_code`, 200)).to.equal(\"number\");\n            }\n      \n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].message' has 'message' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].message`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].message`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 422){\n    pm.test(\"Validation Failed\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Unprocessable Entity (WebDAV) (RFC 4918)\");\n        pm.test('Response has the `errors` field',function(){\n            if(pm.expect(pm.response.json()).to.have.nested.property(`errors`)){\n                if(pm.expect(ld.get(pm.response.json(), `errors`)).to.exist){\n                  pm.expect(Array.isArray(ld.get(pm.response.json(), `errors`))).to.equal(true);\n                }\n\n            }\n\n        })\n \n        pm.test('errors has unique values',function(){\n          pm.expect(ld.uniq(ld.get(responseData, \"errors\", [])).length).to.be.eql(_.get(responseData, \"errors\", []).length);\n        })\n\n        pm.test(`Each object in the errors field has all the required fields`,function(){\n            pm.expect(pm.response.json()).to.have.nested.property(`errors`);\n            let errorsArray = ld.get(pm.response.json(), `errors`, \"\");\n            for (let errors_it = 0; errors_it < errorsArray.length; errors_it++) {\n                let iterator = errors_it;\n                \t\n        pm.test(`${iterator} element of array 'errors[${errors_it}].id' has 'id' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].id`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].id`, null)).to.equal(\"string\");\n            }\n        })\n\n  \n        pm.test('errors[${errors_it}].id length to be atmost `255`',function(){\n            pm.expect(ld.get(responseData, \"errors[${errors_it}].id\", \"\").length).to.be.at.most(255);\n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].status' has 'status' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].status`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].status`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].code' has 'code' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].code`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].code`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].title' has 'title' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].title`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].title`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].detail' has 'detail' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].detail`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].detail`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source' has 'source' as 'object'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source`, null)).to.equal(\"object\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.pointer' has 'pointer' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.pointer`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.pointer`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].source.parameter' has 'parameter' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].source.parameter`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].source.parameter`, null)).to.equal(\"string\");\n            }\n        })\n\n\n        pm.test(`${iterator} element of array 'errorsArray'has 'error_code' as number`,function(){ \n            if(pm.expect(ld.get(responseData, `errors[${errors_it}].error_code`, 200)).to.exist){\n              pm.expect(typeof ld.get(responseData,`errors[${errors_it}].error_code`, 200)).to.equal(\"number\");\n            }\n      \n        })\n\n        pm.test(`${iterator} element of array 'errors[${errors_it}].message' has 'message' as 'string'`,function(){ \n            if(pm.expect(ld.get(pm.response.json(), `errors[${errors_it}].message`, null)).to.exist){\n              pm.expect(typeof ld.get(pm.response.json(),`errors[${errors_it}].message`, null)).to.equal(\"string\");\n            }\n        })\n\n\n            }\n\n        })\n\n    });\n\n}\n\nif (pm.response.code == 429){\n    pm.test(\"Rate Limit Exceeded\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Too Many Requests\");\n    });\n\n}\n\nif (pm.response.code == 500){\n    pm.test(\"Oops, something went wrong!\", function () {\n        pm.expect(pm.response.status).to.be.eql(\"Internal Server Error\");\n    });\n\n}\n"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          }
        },
        {
          "id": "4700632c-5d60-4b49-8ba9-e791666230d7",
          "name": "{id}",
          "item": [
            null,
            null,
            null
          ],
          "event": []
        }
      ],
      "event": []
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "string",
      "value": "https://api.confluent.cloud",
      "key": "baseUrl"
    },
    {
      "type": "integer",
      "value": 200,
      "key": "statusCode"
    }
  ],
  "info": {
    "_postman_id": "078a1a49-9bcf-470b-945d-dd4a76d79d37",
    "name": "Confluent Cloud APIs",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "# Introduction\n\n<div class=\"status-info\">\n<p class=\"status-info-title\">Note</p>\nThis documents the collection of Confluent Cloud APIs. Each API documents its\n<a href=\"#section/Versioning/API-Lifecycle-Policy\">lifecycle phase</a>. APIs\nmarked as Early Access or Preview are not ready for production usage. We're currently\nworking with a select group of customers to get feedback and iterate on these APIs.\n</div>\n\nConfluent Cloud APIs are a core building block of Confluent Cloud. You can use the APIs to\nmanage your own account or to integrate Confluent into your product.\n\nMost of the APIs are organized around\n<a href=\"http://en.wikipedia.org/wiki/Representational_State_Transfer\" target=\"_blank\">REST</a>\nand the resources which make up Confluent Cloud. The APIs have predictable\nresource-oriented URLs, transport data using JSON, and use standard HTTP verbs,\nresponse codes, authentication, and design principles.\n\n# Object Model\n\n<div class=\"status-info\">\n<p class=\"status-info-title\">Note</p>\nThis section describes the object model for many Confluent Cloud APIs, but not all.\nThe Connect v1 API group has a different object model. You can review the example\nrequest and response bodies in <a href=\"#tag/Connectors-(v1)\">Connect v1 API</a>\nto see its object model.\n</div>\n\nConfluent Cloud APIs are primarily designed to be declarative and intent-oriented. In other words, \ntell the API what you want (for example, throughput or SLOs) and it will figure out how to make it happen \n(for example, cluster sizing). A Confluent object acts as a \"record of intent\" — after you create the\nobject, Confluent Cloud will work tirelessly in the background to ensure that the object exists\nas specified.\n\nConfluent APIs represent objects in JSON with media-type `application/json`.\n\nMany objects follow a model consisting of `spec` and `status`. An object's `spec` tells\nConfluent the _desired state_ (specification) of the resource. The object may not be\nimmediately available or changes may not be immediately applied. For this reason,\nmany objects also have a `status` property that provides info about the\n_current state_ of the resource. Confluent Cloud is continuously and actively managing\neach resource's current state to match it's desired state.\n\nAll Confluent objects share a set of common properties:\n\n* **api_version** – API objects have an `api_version` field indicating their API version.\n* **kind** – API objects have a `kind` field indicating the kind of object it is.\n* **id** – Each object in the API will have an identifier, indicated via its `id` field,\n  and should be treated as an opaque string unless otherwise specified.\n\nThere are a number of other [standard properties](#standard-properties) and that you'll encounter\nused by many API objects. And of course, objects have plenty of non-standard fields that are\nspecific to each object _kind_... this is what makes them interesting!\n\n# Authentication\n\nConfluent uses API keys and Java Web Tokens (JWTs) to integrate your applications\nand workflows to your Confluent Cloud resources using the Confluent Cloud REST APIs.\nYour applications and workflows must be authenticated and authorized in order to\naccess and manage Confluent Cloud resources.\n\n## API keys\n\nYou can create and manage your API keys using the Confluent Cloud Console or\nConfluent CLI. For more information, see [Use API Keys to Control Access in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html).\n\nConfluent Cloud uses the following two categories of API keys:\n\n* A **Cloud API key** grants access to the Confluent Cloud Management APIs,\n  such as for Provisioning and Metrics integrations.\n* A **resource-specific API key** grants access to a Confluent Kafka cluster\n  (Kafka API key), a Confluent Cloud Schema Registry (Schema Registry API key),\n  or a ksqlDB application.\n\nEach Confluent Cloud API key is associated with a principal (specific user or\nservice account) and inherits the permissions granted to the owner.\n\n* For example, if service account `Armageddon` is granted ACLs on Kafka cluster\n  `neptune`, then a Kafka API Key for `neptune` owned by `Armageddon` will have\n  these ACLs enforced.\n* **Note:** API keys are automatically deleted when the associated user or service\n  account is deleted (for example, when an employee leaves the company or moves to\n  a new department and an SSO integration removes the Confluent Cloud user as they\n  no longer require access).\n* Confluent **strongly recommends** that you use service accounts for all\n  production-critical access.\n\nConfluent Cloud API keys grant access to Confluent Cloud resources, so **keep them secure**!\nDo not share your API keys and secrets in publicly-accessible locations, such as \nGitHub or client-side code.\n\nAll API requests must be made over HTTPS. Calls made over plain HTTP will fail.\nAPI requests without authentication will also fail.\n\nTo use an API key, you must send it in an `Authorization: Basic {credentials}` header.\nRemember that HTTP Basic authentication requires you to provide your credentials as\nthe API key ID and associated API secret separated by a colon and encoded using Base64\nformat. For example, if your API key ID is `ABCDEFGH123456789` and the API key Secret \nis `XNCIW93I2L1SQPJSJ823K1LS902KLDFMCZPWEO`, then the authorization header is:\n\n```text​\nAuthorization: Basic QUJDREVGR0gxMjM0NTY3ODk6WE5DSVc5M0kyTDFTUVBKU0o4MjNLMUxTOTAyS0xERk1DWlBXRU8=\n```\n\nYou can generate this header example from the API key:\n\nmacOS:\n\n```shell\n$ echo -n \"ABCDEFGH123456789:XNCIW93I2L1SQPJSJ823K1LS902KLDFMCZPWEO\" | base64\n\n```\n\nLinux:\n\n```shell\n$ echo -n \"ABCDEFGH123456789:XNCIW93I2L1SQPJSJ823K1LS902KLDFMCZPWEO\" | base64 -w 0\n```\n\nTo find out if an API operation supports Cloud API Keys, look in the **AUTHORIZATIONS**\nlisting for `cloud-api-key`.\n\nTo find out if an API operation supports resource-specific API Keys, look in the **AUTHORIZATIONS**\nlisting for `resource-api-key`.\n\n## External OAuth\n\nYou can use [OAuth/OIDC support for Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/overview.html)\nto authenticate and authorize access to applications and workloads for the\nfollowing Confluent Cloud REST APIs:\n\n* **Kafka REST API**: [Kafka REST API for Clusters(V3)](https://docs.confluent.io/cloud/current/api.html#tag/Cluster-(v3)).\n  For an API overview and examples, see [Cluster Management with Kafka REST API](https://docs.confluent.io/cloud/current/kafka-rest/kafka-rest-cc.html).\n* **Schema Registry REST API**: [Schema Registry REST API for Schemas(V1)](https://docs.confluent.io/cloud/current/api.html#tag/Schemas-(v1))\n  and [Subjects](https://docs.confluent.io/cloud/current/api.html#tag/Subjects-(v1)).\n  For an API overview and examples, see [Schema Registry REST API for Confluent Cloud](https://docs.confluent.io/cloud/current/sr/sr-rest-apis.html).\n\nAlternatively, to find out if an API operation supports external tokens, look in the **AUTHORIZATIONS**\nlisting for `external-access-token`.\n\n## Confluent STS tokens\n\nConfluent Security Token Service (STS) issues access tokens (`confluent-sts-access-token`)\nby exchanging an external token (`external-access-token`) for a `confluent-sts-access-token`. You can use\nConfluent STS tokens to authenticate to Confluent Cloud APIs that support the\n`confluent-sts-access-token` notation.\n\nTo find out if an API operation supports Confluent STS tokens, look in the **AUTHORIZATIONS**\nlisting for `confluent-sts-access-token`.\n\n## Partner OAuth\n\nApproved partners can fetch Partner tokens (`confluent-partner-access-token`) that validate their identity\nand grant access to the Partner API (`partner/v2`), which lets them sign up\nan organization on behalf of a customer, manage entitlements (create, read, and list),\nand read or list organizations they have signed up.\n\nTo find out an API operation supports Partner tokens, look in the **AUTHORIZATIONS**\nlisting for `confluent-partner-access-token`.\n\n<!-- TODO: port this back to the Confluent API Design Guide -->\n\n<SecurityDefinitions />\n\n# Errors\n\n<div class=\"status-info\">\n<p class=\"status-info-title\">Note</p>\nThis section describes the structure of error responses for many Confluent Cloud APIs, but not all.\nThe Connect v1 API group has a different set of structures for error responses. Please review the example\nrequest and response bodies in the Connect v1 API documentation <a href=\"#tag/Connectors-(v1)\">below</a>\nto see its error behaviour.\n</div>\n\nConfluent uses conventional [HTTP status codes](#section/HTTP-Guidelines/Status-Codes) to\nindicate the success or failure of an API request.\n\nFailures follow a standard model to tell you about what went wrong. They may include\none or more error objects with the following fields:\n\n| Field      | Type    | Description\n|------------|---------|--------------------------------------\n| id*        | UUID    | A unique identifier for this particular occurrence of the problem.\n| status     | String  | The HTTP status code applicable to this problem.\n| code       | String  | An application-specific error code.\n| title      | String  | A short, human-readable summary of the problem that **should not** change from occurrence to occurrence of the problem, except for purposes of localization.\n| detail*    | String  | A human-readable explanation specific to this occurrence of the problem. Like title, this field’s value can be localized.\n| source     | Object  | An object that references the source of the error, and optionally includes any of the following members:\n| &nbsp;&nbsp;pointer   | String  | A <a href=\"https://tools.ietf.org/html/rfc6901\" target=\"_blank\">JSON Pointer</a> to the associated entity in the request document (e.g. `\"/spec/title\"` for a specific attribute).\n| &nbsp;&nbsp;parameter | String  | A string indicating which URI query parameter caused the error.\n| meta       | Object  | A meta object that contains non-standard meta-information about the error.\n| resolution | String  | Instructions for the end-user for correcting the error.\n\n\\* indicates a required field\n\nAll errors include an `id` and some `detail` message. The `id` is a unique identifier — use it\nwhen you're working with Confluent support to debug a problem with a specific API call. The\n`detail` describes what went wrong.\n\nSome errors that could be handled programmatically (e.g., a Kafka cluster config is invalid)\nmay include an error `code` that briefly explains the error reported.\n\nValidation issues and similar errors include a `source` which tells you exactly\nwhat in the request was responsible for the error.\n\nFor example, a failure may look like\n\n    {\n      \"errors\": [{\n        \"status\": \"422\",\n        \"code\": \"invalid_configuration\",\n        \"id\": \"30ce6058-87da-11e4-b116-123b93f75cba\",\n        \"title\": \"The Kafka cluster configuration is invalid\",\n        \"detail\": \"The property '/cluster/storage_size' of type string did not match the following type: integer\",\n        \"source\": {\n          \"pointer\": \"/cluster/storage_size\"\n        }\n      }]\n    }\n\nIf a request fails validation, it will return an HTTP `422 Unprocessable Entity`\nwith a list of fields that failed validation.\n\n# Pagination\n\n<div class=\"status-info\">\n<p class=\"status-info-title\">Note</p>\nThis section describes the pagination behavior of “list” operations for many Confluent Cloud APIs, but not all.\nThe Connect v1 API list operations do not support pagination.\n</div>\n\nAll API resources have support for bulk reads via \"list\" API operations. For example,\nyou can \"list Kafka clusters\", \"list api keys\", and \"list environments\". These \"list\"\noperations require pagination; by requesting smaller subsets of data, API clients\nreceive a response much faster than requesting the entire, potentially large, data set.\n\nAll \"list\" operations follow the same pattern with the following parameters:\n\n* `page_size` –  client-provided max number of items per page, only valid on the first request.\n* `page_token` –  server-generated token used for traversing through the result set.\n\nA paginated response may include any of the following pagination links. API clients may\nfollow the respective link to page forward or backward through the result set as desired.\n\n| [Link Relation](https://www.iana.org/assignments/link-relations/link-relations.xml) | Description\n|---------|---------------------------------------\n| `next`  | A link to the next page of results. A response that does not contain a next link does not have further data to fetch.\n| `prev`  | A link to the previous page of results. A response that does not contain a prev link has no previous data. This link is **optional** for collections that cannot be traversed backward.\n| `first` | A link to the first page of results. This link is **optional** for collections that cannot be indexed directly to a given page.\n| `last`  | A link to the last page of results. This link is **optional** for collections that cannot be indexed directly to a given page.\n\nAPI clients must treat pagination links and the `page_token` parameter in particular as an opaque string. \n\nAn example paginated list response may look like\n```\n{\n    \"api_version\": \"v2\",\n    \"kind\": \"KafkaClusterList\",\n    \"metadata\": {\n        \"next\": \"https://api.confluent.cloud/kafka-clusters?page_token=ABCDEFGHIJKLMNOP1234567890\"\n    }\n    \"data\": [\n        {\n            \"metadata\": {\n                \"id\": \"lkc-abc123\",\n                \"self\": \"https://api.confluent.cloud/kafka-clusters/lkc-abc123\",\n                \"resource_name\": \"crn://confluent.cloud/kafka=lkc-abc123\",\n            }\n            \"spec\": {\n                \"display_name\": \"My Kafka Cluster\",\n                <snip>\n            },\n            \"status\": {\n                \"phase\": \"RUNNING\",\n                <snip>\n            }\n        },\n        <snip>\n    ]\n}\n```\n\n# Rate Limiting\n\nTo protect the stability of the API and keep it available to all users, Confluent employs\nmultiple safeguards. If you send too many requests in quick succession or perform too many\nconcurrent operations, you may be throttled or have your request rejected with an error.\n\nWhen a rate limit is breached, an HTTP `429 Too Many Requests` error is\nreturned. The following headers are sent back to provide assistance in dealing\nwith rate limits. Note that headers are not returned for a `429` error response with \n[Kafka REST API (v3)](https://docs.confluent.io/cloud/current/api.html#tag/Cluster-(v3)).\n\n| Header                  | Description\n|-------------------------|----------------------------------------\n| `X-RateLimit-Limit`     | The maximum number of requests you're permitted to make per time period.\n| `X-RateLimit-Reset`     | The relative time in seconds until the current rate limit window resets.\n| `Retry-After`           | The number of seconds to wait until the rate limit window resets. Only sent when the rate limit is reached.\n| `X-RateLimit-Remaining` | The number of requests remaining in the current rate-limit window. **Important:** This differs from Github and Twitter\\'s same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues.\n\n\nConfluent enforces multiple kinds of limits, including request-rate and concurrency limits, both per user and organization-wide. Unauthenticated requests are associated with the originating IP address, not the user making requests.\n\n\nIntegrations should gracefully handle these limits by watching for `429` error responses and\nbuilding in a retry mechanism. This mechanism should follow a capped exponential backoff policy to\nprevent [retry amplification](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/)\n(\"retry storms\") and also introduce some randomness (\"jitter\") to avoid the\n[thundering herd effect](https://en.wikipedia.org/wiki/Thundering_herd_problem).\n\n\nIf you’re running into this error and think you need a higher rate limit, contact Confluent at\n[support@confluent.io](mailto:support@confluent.io).\n\n# Identifiers and URLs\n\nMost resources have multiple identifiers:\n* `id` is the \"natural identifier\" for an object. It is only unique within its parent resource.\n  The `id` is unique across time: the ID will not be reclaimed and reused after an object is deleted.\n* `resource_name` is a Uniform Resource Identifier (URI) that is globally unique across all resources.\n  This encompasses all parent resource `kind`s and `id`s necessary to uniquely identify a particular\n  instance of this object `kind`. Because it uses object `id`s, the CRN will not be reclaimed and\n  reused after an object is deleted. It is represented as a Confluent Resource Name (see below). \n* `self` is a Uniform Resource Locator (URL) at which an object can be addressed.\n  This URL encodes the service location, API version, and other particulars necessary to\n  locate the resource at a point in time.\n\nTo see how these relate to each other, consider `KafkaBroker` with `broker.id=2` in a `KafkaCluster`\nin Confluent Cloud identified as `lkc-xsi8201`. In such an example, the `KafkaBroker` has `id=2`,\nthe `resource_name` is `crn://confluent.cloud/kafka=lkc-xsi8201/broker=2` and the `self` URL may be\nsomething like `https://pkc-8wlk2n.us-west-2.aws.confluent.cloud`. Note that different identifiers\ncarry different information for different purposes, but the `resource_name` is the most complete\nand canonical identifier.\n\n## Confluent Resource Names (CRNs)\n\n*Confluent Resource Names* (CRNs) are used to uniquely identify all Confluent resources.\n\nA CRN is a valid URI having an \"authority\" of `confluent.cloud` or a self-managed\n<a href=\"https://docs.confluent.io/current/security/rbac/configure-mds/index.html\" target=\"_blank\">\nmetadata service URL</a>, followed by the minimal hierarchical set of key-value\npairs necessary to uniquely identify a resource.\n\nHere are some examples for basic resources in Confluent Cloud:\n\n| Resource                   | Example CRN                                                                                                                                                              |\n|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Organization               | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a                                                                                                  |\n| Environment                | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy                                                                            |\n| User                       | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/user=u-rst9876                                                                                   |\n| API Key                    | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/user=u-zyx98/api-key=ABCDEFG9876543210                                                           |\n| Service Account            | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/service-account=sa-abc1234                                                                       |\n| Kafka Cluster              | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/cloud-cluster=lkc-123abc/kafka=lkc-123abc                                  |\n| Kafka Topic                | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/cloud-cluster=lkc-123abc/kafka=lkc-123abc/topic=my_kafka_topic             |\n| Consumer Group             | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/cloud-cluster=lkc-123abc/kafka=lkc-123abc/group=confluent_cli_consumer_123 |\n| Network                    | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/network=n-123abc                                                           |\n| Peering                    | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/network=n-123abc/peering=p-123abc                                          |\n| Private Link Access        | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/network=n-123abc/private-link-access=pla-123abc                            |\n| Transit Gateway Attachment | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/network=n-123abc/transit-gateway-attachment=tgwa-123abc                    |\n| Schema Registry Cluster    | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/schema-registry=lsrc-789qw                                                 |\n| Schema Subject             | crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-456xy/schema-registry=lsrc-789qw/subject=test                                    |\n\n# Data Types\n\n## Primitive Types\n\n| Data Type  | Representation\n|------------|---------------------\n| Integers   | Each API may specify the type as `int32` or `int64`. Note that many languages, including JavaScript, are limited to a max size of approx `2**53` and don't correctly handle large `int64` values with their default JSON parser.\n| Dates      | <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> formatted string. UTC timezones are assumed, unless otherwise given.\n| Times      | <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> formatted string. UTC timezones are assumed, unless otherwise given.\n| Durations  | <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> formatted string.\n| Periods    | <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> formatted string. UTC timezones are assumed, unless otherwise given.\n| Ranges     | All ranges are represented using half-open intervals with naming conventions like `[start_XXX, end_XXX)` such as `[start_time, end_time)`.\n| Enums      | Most APIs use <a href=\"https://opensource.zalando.com/restful-api-guidelines/#112\" target=\"_blank\">`x-extensible-enum`</a> as an open-ended list of values. This improves compatibility compared with a standard `enum` which by definition represents a closed set. All enums have a `0`-valued entry which either serves as the default for common cases, or represents `UNSPECIFIED` when no default exists and results in an error.\n\n<!-- TODO\n### Standard Objects\n\n| Money Object | https://schema.org/MonetaryAmount or https://opensource.zalando.com/restful-api-guidelines/#173\n| Price Specification | https://schema.org/PriceSpecification -> https://schema.org/UnitPriceSpecification and https://schema.org/PaymentChargeSpecification\n-->\n\n### Standard Properties\n\nConfluent uses this set of standard properties to ensure common concepts use\nthe same name and semantics across different APIs.\n\n| Name             | Description\n|------------------|------------------------------------------\n| **api_version**  | Many API objects have an `api_version` field indicating their API version. See the [Object Model](#section/Object-Model).\n| **kind**         | Many API objects have a `kind` field indicating the kind of object it is. See the [Object Model](#section/Object-Model).\n| **id**           | Many objects in the API will have an identifier, indicated via its `id` field, and should be treated as an opaque string unless otherwise specified. See the [Object Model](#section/Object-Model).\n| **name**         | Objects which support a client-provided unique identifier instead of a generated `id` will indicate this identifier via its `name` field.\n| **display_name** | The human-readable display name of an API object.\n| **title**        | The official name of an API object, such as a company name. It should be treated as the formal version of `display_name`.\n| **description**  | One or more paragraphs of text description of an entity.\n| **created_at**   | The date and time the object was created, represented as a string in <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> format.\n| **updated_at**   | The date and time the object was last modified, represented as a string in <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> format.\n| **deleted_at**   | If present, the date and time after which the object was/will be deleted, represented as a string in <a href=\"https://www.ietf.org/rfc/rfc3339.txt\" target=\"_blank\">RFC 3339</a> format.\n| **page_token**   | The pagination token in the List request. See [Pagination](#section/Pagination).\n| **page_size**    | The pagination size in the List request. See [Pagination](#section/Pagination).\n| **total_size**   | The total count of items in the list irrespective of pagination. See [Pagination](#section/Pagination).\n| **spec**         | The _desired state_ specification of the resource, as observed by Confluent Cloud.\n| **status**       | The _current state_ of the resource, as observed by Confluent Cloud.\n\n# Versioning\n\nConfluent APIs ensure stability for your integrations by avoiding the introduction\nof breaking changes to customers unexpectedly. Confluent will make non-breaking\nAPI changes without advance notice. Thus, API clients **must**  follow the\n[Compatibility Policy](#section/Versioning/Compatibility-Policy) below to ensure your\ningtegration remains stable. All APIs follow the API Lifecycle Policy described below,\nwhich describes the guarantees API clients can rely on.\n\nBreaking changes will be [widely communicated](#communication) in advance in accordance\nwith the Confluent [Deprecation Policy](#section/Versioning/Deprecation-Policy). Confluent will provide \ntimelines and a migration path for all API changes, where available. Be sure to subscribe\nto one or more [communication channels](#communication) so you don't miss any updates!\n\nOne exception to these guidelines is for critical security issues. Confluent will take any necessary\nactions to mitigate any critical security issue as soon as possible, which may include disabling\nthe vulnerable functionality until a proper solution is available.\n\nDo not consume any Confluent API unless it is documented in the API Reference. All undocumented\nendpoints should be considered private, subject to change without notice, and not covered by any\nagreements.\n\n> Note: The version in the URL (e.g. \"v1\" or \"v2\") is not a \"major version\" in the\n[Semantic Versioning](https://semver.org/) sense. It is a \"generational version\" or \"meta version\", as seen in\nAPIs like <a href=\"https://developer.github.com/v3/versions/\" target=\"_blank\">Github API</a> or the\n<a href=\"https://stripe.com/docs/api/versioning\" target=\"_blank\">Stripe API</a>.\n\n## API Groups\n\nConfluent APIs are divided into API Groups, such as the Cluster Management for Apache Kafka (CMK) API group,\nthe Connect API group, and the Data Catalog API group. Each group has its own set of endpoints and resources,\nas well as its own API group version.\n\nBecause different API groups have different versions, there is no single version for the \"Confluent Cloud API\".\nThe latest version of the Connect API group may be `connect/v1`, while the latest version of the CMK API group\nmay be `cmk/v2`.\n\nWhen a breaking change is introduced into one API group, Confluent will increase the API version for that API group\nonly, leaving the other API groups' versions unchanged. This makes it easier for you to understand whether a given\nbreaking change impacts your usage of the APIs.\n\n## Known Issues\n\nDuring the Early Access and Preview periods, we have a few known issues.\n\n| Issue          | Description                                                                   | Proposed Resolution\n|----------------|-------------------------------------------------------------------------------|-----------------------------------------------------\n| Quota Exceeded | Some \"Quota Exceeded\" errors will be returned as HTTP 400 instead of HTTP 402 | Return 402 consistently for \"Quota Exceeded\" errors \n\n## API Lifecycle Policy\n\nThe following status labels are applicable to APIs, features, and SDK versions, based on\nthe current support status of each:\n\n* **Early Access** – May change at any time. Not recommended for production usage. Not officially supported by\n  Confluent. Intended for user feedback only. Users must be granted explicit access to the API by Confluent.\n* **Preview** – Unlikely to change between Preview and General Availability. Not recommended for production usage.\n  Officially supported by Confluent for non-production usage. Accessible to all users.\n* **Limited Availability (LA)** - Available to key select customers in a subset of regions/providers/networks and recommended for production usage.  \n* **Generally Available (GA)** – Will not change at short notice. Recommended for production usage.\n  Officially supported by Confluent for non-production and production usage.\n* **Deprecated** – Still supported, but no longer under active development. Existing usage will continue to function\n  but migration following the upgrade guide is strongly recommended. New use cases should be built against the new\n  version. Deprecated feature or version will be removed in the future at the announced date.\n* **Sunset** – Removed, and no longer supported or available.\n\nAn API is \"Generally Available\" unless explicitly marked otherwise.\n\n## Compatibility Policy\n\nConfluent Cloud APIs are governed by\n<a href=\"https://docs.confluent.io/cloud/current/clusters/upgrade-policy.html\" target=\"_blank\">\nConfluent Cloud Upgrade Policy</a>, which means that backward incompatible changes and\ndeprecations will be made approximately once per year, and 180 days notice will be provided via email to all\nregistered Confluent Cloud users.\n\n### Backward Compatibility\n\n> _An API version is backward compatible if a program written against the previous version of the API will continue to work the same way, without modification, against this version of the API._\n\nConfluent considers the following changes to be backward compatible:\n\n* Adding new API resources.\n* Adding new optional parameters to existing API requests (e.g., query string).\n* Adding new properties to existing API resources (e.g., request body).\n* Changing the order of properties in existing API responses.\n* Changing the length or format of object IDs or other opaque strings.\n  * Unless otherwise documented, you can safely assume object IDs generated by Confluent will never exceed 255\n    characters, but you should be able to handle IDs of up to that length. If you're using MySQL,\n    for example, you should store IDs in a `VARCHAR(255) COLLATE utf8_bin` column.\n  * This includes adding or removing fixed prefixes (such as `lkc-` on Kafka cluster IDs).\n  * This includes API keys, API tokens, and similar authentication mechanisms.\n  * This includes all strings described as \"opaque\" in the docs, such as pagination cursors.\n* Adding new API event types.\n* Adding new properties to existing API event types.\n* Omitting properties with null values from existing API responses.\n\n### Forward Compatibility\n\n> _An API version is forward compatible if a program written against the next version of the API\n> will continue to work the same way, without modification, against this version of the API._\n\nIn other words, a forward compatible API will accept input intended for a later version of itself.\n\nConfluent does not guarantee the forward compatibility of the APIs, but Confluent does generally follow the guidelines\ngiven by the [Robustness principle](https://en.wikipedia.org/wiki/Robustness_principle).\nThis means that the API determines what to do with a request based only on the parts that it recognizes.\n\nThis is often referred to as the MUST IGNORE rule.\n\n* Request parameters that are not recognized will be ignored (e.g., query string).\n* Request properties that are not recognized will be ignored (e.g., request body).\n* Request metadata that are not recognized will be ignored (e.g., request headers).\n\nAPI clients must also follow the MUST IGNORE rule.\n\n* Response properties that are not recognized must be ignored (e.g., response body).\n* Response metadata that are not recognized must be ignored (e.g., response headers).\n\nAdditionally, there is a more subtle related rule called the MUST FORWARD rule. Any parts of\na request that an API doesn't recognize must be forwarded unchanged.\n\n* Response properties that are not recognized must be included in any input subsequent updates (e.g., request body)\n  * This includes future `PUT` requests in a read/modify/write operation.\n    (This isn't required for `PATCH` partial updates, which is why Confluent APIs use `PATCH`.)\n* Event processors must not strip unknown properties before forwarding messages.\n\n### Client Responsibilities\n\n* Resource and rate limits, and the default and maximum sizes of paginated data **are not**\n  considered part of the API contract and may change (possibly dynamically). It is the client's\n  responsibility to read the road signs and obey the speed limit.\n* If a property has a primitive type and the API documentation does not explicitly limit its\n  possible values, clients **must not** assume the values are constrained to a particular set\n  of possible responses.\n* If a property of an object is not explicitly declared as mandatory in the API, clients\n  **must not** assume it will be present.\n* A resource **may** be modified to return a \"redirection\" response (e.g. `301`, `307`) instead of\n  directly returning the resource. Clients **must** handle HTTP-level redirects, and respect HTTP\n  headers (e.g. `Location`).\n\n## Deprecation Policy\n\nConfluent will announce deprecations at least 180 days in advance of a breaking change\nand will continue to maintain the deprecated APIs in their original form during this time.\n\nExceptions to this policy apply in case of critical security vulnerabilities or functional defects.\n\n### Communication\n\nWhen a deprecation is announced, the details and any relevant migration\ninformation will be available on one or more of the following channels:\n\n* Announcements on the <a href=\"https://www.confluent.io/blog/\" target=\"_blank\">Developer Blog</a>,\n  <a href=\"https://confluentcommunity.slack.com\" target=\"_blank\">Community Slack</a>\n  (<a href=\"https://slackpass.io/confluentcommunity\" target=\"_blank\">join!</a>),\n  <a href=\"https://groups.google.com/forum/#!forum/confluent-platform\" target=\"_blank\">Google Group</a>,\n  the <a href=\"https://twitter.com/ConfluentInc\" target=\"_blank\">@ConfluentInc twitter</a>\n  account, and similar channels\n* Enterprise customers may receive information by email to their specified Confluent contact, if applicable.\n\n<!-- TODO:\n### Discoverability\n-->\n\n# HTTP Guidelines\n\n## Status Codes\n\nConfluent respects the meanings and behavior of HTTP status codes as defined\nin <a href=\"https://tools.ietf.org/html/rfc2616\">RFC2616</a> and elsewhere.\n\n* Codes in the `2xx` range indicate success\n* Codes in the `3xx` range indicate redirection\n* Codes in the `4xx` range indicate an error caused by the client request\n  (e.g., a required parameter was omitted, an invalid cluster configuration was provided, etc.)\n* Codes in the `5xx` range indicate an error with Confluent's servers (these are rare)\n\nThe various HTTP status codes that might be returned are listed below.\n\n| Code | Title                  | Description\n|------|------------------------|--------------------------------\n| 200  | OK                     | Everything worked as expected.\n| 201  | Created                | The resource was created. Follow the `Location` header.\n| 204  | No Content             | Everything worked and there is no content to return.\n| 400  | Bad Request\t        | The request was unacceptable, often due to malformed syntax, or a missing or malformed parameter.\n| 401  | Unauthorized           | No valid credentials provided. or the credentials are unsuitable, invalid, or unauthorized.\n| 402  | Over Quota             | The request was valid, but you've exceeded your plan quota or limits.\n| 404  | Not Found              | The requested resource doesn't exist or you're unauthorized to know it exists.\n| 409  | Conflict               | The request conflicts with another request (perhaps it already exists or was based on a stale version of data).\n| 422  | Validation Failed      | The request was parsed correctly but failed some sort of validation.\n| 429  | Too Many Requests      | Too many requests hit the API too quickly. Confluent recommends an exponential backoff of your requests.\n| 500, 502, 503, 504 | Server Errors | Something went wrong on Confluent's end. (These are rare.)\n\nThis list is not exhaustive; other standard HTTP error codes may be used,\nincluding `304`, `307`, `308`, `405`, `406`, `408`, `410`, and `415`.\n\nFor more details, see https://httpstatuses.com.\n\n<!--\n\n## Method Overriding\n\nSome firewalls and HTTP clients restrict the use of verbs other than `GET` and `POST`. In those\nenvironments, Confluent API operations that require `PUT`, `PATCH`, and `DELETE` verbs will be inaccessible.\n\nTo avoid this issue, Confluent APIs support the `X-HTTP-Method-Override` header, allowing clients to\n\"tunnel\" `PUT`, `PATCH`, and `DELETE` requests via a `POST` request.\n\nFor example, to call a Confluent `PATCH` resource via a `POST` request, you can\ninclude `X-HTTP-Method-Override: PATCH` as a header.\n\n## User Agent Required\n\nConfluent API requests **should** include a valid `User-Agent` header. Requests with no `User-Agent`\nheader may be rejected. You should use the name of your integration for the `User-Agent`\nheader value and include contact information so that Confluent can contact you if there are problems.\n\n> If your integration is acting as a proxy or gateway, you **should** forward the User-Agent\n> of the originating client with your API requests.\n\nHere's a complete example:\n\n    User-Agent: CoolToolName/1.2.3 (https://example.org/CoolTool/; CoolTool@example.org) UsedBaseLibrary/2.1.0\n\nThe minimum user agent string is the integration name and version: `name/version`.\nYou can string together multiple values in a space-separated list. The full syntax is:\n\n    name/version [(comments)] [name/version [(comments)]] [...]​\n\nFor the integration name, use a string (without whitespace) that clearly and meaningfully\nidentifies your integration.\n\n* Avoid ambiguous names: `Confluent-Integration`, `Kafka-Sink`\n* Use clear and meaningful names: `ABCTools-ToolName`, `StackStorm-Confluent-Plugin`\n\nFor the version, use a semantic version, build ID, commit hash, or other identifier\nthat is updated automatically when you release a new version.\n\nWrap comments in parentheses `()` as a semi-colon separated list. Helpful comments to include:\n\n* A public URL for your integration, such as a GitHub link or a page in your\n  docs site that describes the integration.\n* Contact information so that Confluent can easily reach the integration publisher. This\n  information from the user agent string will never be shared nor used by Confluent for\n  any purpose other than discussing the integration with its publisher.\n\nIf you provide an invalid `User-Agent` header, you may receive a `403 Forbidden` response.\n\n-->\n\n# Metrics APIs\n\nFor Metrics APIs, see <a href=\"https://api.telemetry.confluent.cloud/docs\">Confluent Cloud Metrics API</a>.\n\n\nContact Support:\n Name: Confluent Cloud\n Email: support@confluent.io",
      "type": "text/plain"
    }
  }
}